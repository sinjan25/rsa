/*
Sinjan Chakraborty
Jadavpur University, Kolkata,
Implementation of RSA in C
*/

//Firstly I have generated the first 10,000 prime numbers from 2 to 150,000.
//Generation of those primes

#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <limits.h>

long long phi,M,n,e,d,C;

#define LIMIT 150000 /*size of integers array*/
#define PRIMES 10000 /*size of primes array*/

int preselection(int k){
    int i,j,numbers[LIMIT];
    int primes[PRIMES];

    /*fill the array with natural numbers*/
    for (i=0;i<LIMIT;i++){
        numbers[i]=i+2;
    }

    /*sieve the non-primes*/
    for (i=0;i<LIMIT;i++){
        if (numbers[i]!=-1){
            for (j=2*numbers[i]-2;j<LIMIT;j+=numbers[i])
                numbers[j]=-1;
        }
    }
    
    /*transfer the primes to their own array*/
    j = 0;
    for (i=0;i<LIMIT && j<PRIMES;i++)
        if (numbers[i]!=-1)
            primes[j++] = numbers[i];

    return primes[k];
}

/* This function calculates (a^b)%c */
int modulo(int a,int b,int c){
    long long x=1,y=a; // long long is taken to avoid overflow of intermediate results
    while(b > 0){
        if(b%2 == 1){
            x=(x*y)%c;
        }
        y = (y*y)%c; // squaring the base
        b /= 2;
    }
    return x%c;
}

/* this function calculates (a*b)%c taking into account that a*b might overflow */
long long mulmod(long long a,long long b,long long c){
    long long x = 0,y=a%c;
    while(b > 0){
        if(b%2 == 1){
            x = (x+y)%c;
        }
        y = (y*2)%c;
        b /= 2;
    }
    return x%c;
}

/* Fermat's test for checking primality, the more iterations the more is accuracy */
int Fermat(long long p,int iterations){
    if(p == 1){ // 1 isn't prime; this conditional statement is not required for our given program. We write it for maintaining generality.
        return 0;                       
    }   
    int i=0;            
    for(i=0;i<iterations;i++){
        // choose a random integer between 1 and p-1 ( inclusive )
        long long a = rand()%(p-1)+1; 
        // modulo is the function we developed above for modular exponentiation.
        if(modulo(a,p-1,p) != 1){ 
            return 0; /* p is definitely composite */
        }
    }
    return 1; /* p is probably prime */
}


/* Miller-Rabin primality test, iteration signifies the accuracy of the test */
int Miller(long long p,int iteration){
    if(p<2){  //this conditional statement is not required for our given program. We write it for maintaining generality.
        return 0;
    }
    if(p!=2 && p%2==0){
        return 0;
    }
    long long s=p-1;
    while(s%2==0){
        s/=2;
    }
    int i=0;
    for(i=0;i<iteration;i++){
        long long a=rand()%(p-1)+1,temp=s;
        long long mod=modulo(a,temp,p);
        while(temp!=p-1 && mod!=1 && mod!=p-1){
            mod=mulmod(mod,mod,p);
            temp *= 2;
        }
        if(mod!=p-1 && temp%2==0){
            return 0;
        }
    }
    return 1;
}


//Encrypt fuction
void encrypt(){
      long long i;
      C = 1;
      for(i=0;i< e;i++)
      C=C*M%n;
      C = C%n;
      printf("\n\tEncrypted keyword : %lld",C);
}

//Decrypt function
void decrypt(){
      long long i;
      M = 1;
      for(i=0;i< d;i++)
            M=M*C%n;
            M = M%n;
      printf("\n\tDecrypted keyword : %lld\n",M);
}



//GCD function
long long gcd(long long num_1,long long num_2){
        while (num_1!=num_2){
                if (num_1>num_2)
                      return gcd(num_1-num_2,num_2);
                else
                      return gcd(num_1,num_2-num_1);
        }
        return (num_1);
}




//Main function

int main(void){
    
    srand(time(NULL));        
    float x; 
    long long p,q;  //will store the 2 generated primes
    long long s;
    int gen=0;
    long long prim[2];
    int ferver=0, mrver=0;//stores results of Fermat Primality Test and Miller-Rabin Primality Test  

    
    int i=0;// loop variable
    
    for(i=0;i<=1;i++){
    //For one number
      do{  
         ferver=0;
         mrver=0;
         
         do{
            x=rand();
            gen=10000*x/RAND_MAX;
         }while(gen<1000);   //it means that if the value of gen generated is les than 10000, then it will again generate a new value.
      
         long long a=0;
      
         //These is the prime generated by sieve of eratosthenes
         a=preselection(gen);
        
         //Now we will apply Fermat's Primality Test on a and b. So we call the function Fermat(long long,int).
         ferver=Fermat(a,10);
      
         //Fermat's test is not enough. So we do Miller-Rabin Primality Test if it satifies Fermat's test.
         if(ferver)
             mrver=Miller(a,20);
             
         if(mrver){
             prim[i]=a;
             break;
         }
             
      }while(1); 
    }
    
    // These are our two generated primes
    p=prim[0];
    q=prim[1];    
    
    printf("%lld \n%lld \n",p,q);
    //Now ask for the message to be entered
    
    n=p*q;
    phi=(p-1)*(q-1);
    
    printf("\n\t F(n) phi value \t= %lld",phi);
    
    //Now we need an integer e less than phi such that it is co-prime to phi(n)
    //We will generate this e,i.e., the public exponent
    long long gd=0;
    do{
            x=rand();
            e=x;
            e=e%phi;   
            gd=gcd(e,phi);
            if(gd==1)
                break;
                
    }while(1);  //we go on checking until we get the e that satisfies the right conditions
    
    
    //Calculating d,i.e., the private exponent
    d=1;
    
    do{
            s = (d*e)%phi;
            d++;
    }while(s!=1);
    
    d=d-1;
    
    printf("\n\tPublic Key\t: {%lld,%lld}",e,n);
    printf("\n\tPrivate Key\t: {%lld,%lld}",d,n);
    printf("\n\nEnter The Plain Text\t: ");
    scanf("%lld",&M);
    encrypt();
    
    printf("\n\nEnter the Cipher text\t: ");
    scanf("%lld",&C);
    decrypt();
    
    return 0;
}
